<!-- .slide: class="center" -->

# AQGEO 2024: A tour on potential fields modelling

## Santiago Soler

### UBC-GIF

November 7, 2024

---

## Layout

1. Recap on gravity and magnetic fields.
1. Analytic solutions for rectangular prisms.
1. Implementation for a single source and single receiver.
1. SimPEG: implementation for regular meshes.
1. Inversion.

---

## Motivation

> Maybe add a motivation slide, showing that we usually measure data above the
> earth surface, we remove the normal earth and the igrf field, so we can get the
> signal of bodies with anomalous densities or magnetized bodies.

---

## Recap on gravity and magnetic fields

> Image of arbitrary body, with density and magnetization.
> General equations for gravity and magnetic fields generated by it.

<div class="container">
<div class="col-1">

### Gravity fields

Gravity potential:

$$
V(\mathbf{p}) =
    G \int\limits_\Gamma
        \frac{\rho}{|\mathbf{p} - \mathbf{q}|}
    \text{d}\mathbf{q}
$$

### Magnetic fields

Assume no currents: $ \nabla_\mathbf{p} \times \mathbf{B} = 0 $

Magnetic field:

$$
\mathbf{B}(\mathbf{p}) =
    -\frac{\mu_0}{4\pi}
    \nabla_\mathbf{p}
    \int\limits_\Gamma
    \mathbf{M}
    \cdot
    \nabla_\mathbf{q}
    \left(
        \frac{1}{|\mathbf{p} - \mathbf{q}|}
    \right)
    \text{d}\mathbf{q}
$$

</div>
<div class="col-1">

Image

</div>

</div>

---

## Analytic solutions for rectangular prisms

<!--
> We usually discretize the subsurface using regular meshes. In SimPEG we use
> regular meshes with rectangular cells.
> We assign a constant physical property to each one of the meshes.
> We need a way to compute the fields that the mesh generates on observation
> points in the survey.
-->

> Image of a mesh

* Discretize the subsurface using **regular meshes** with **rectangular cells**.
* Each cell: **homogeneous physical property**.
* Need to **compute the fields** generated by the mesh.
  * **Analytic solutions** of gravity and magnetic fields for **rectangular
    prisms**.

---

<!-- .slide: data-visibility="hidden" -->

## Analytic solutions for rectangular prisms

<!--
> Show a prism with its boundaries.
> Show integral equations.
> Switch to shifted coordinates (coordinate system located on the observation
> point).
--->

<div class="container">
<div class="col-1">

Coordinate system located on $\mathbf{p}$:

$$
\begin{cases}
x = x_q - x_p \newline
y = y_q - y_p \newline
z = z_q - z_p
\end{cases}
$$

* Gravity potential:
  $$
  V(\mathbf{p}) =
    G\rho
    \int_{x_1}^{x_2}
    \int_{y_1}^{y_2}
    \int_{z_1}^{z_2}
      \frac{
        \text{d}x \\,
        \text{d}y \\,
        \text{d}z
      }{
        \sqrt{x^2 + y^2 + z^2}
      }
  $$
* Magnetic field:
  $$
  \mathbf{B}(\mathbf{p}) =
    \frac{\mu_0}{4\pi}
    \nabla_\mathbf{p}
    \int_{x_1}^{x_2}
    \int_{y_1}^{y_2}
    \int_{z_1}^{z_2}
    \mathbf{M}
    \cdot
    \nabla_\mathbf{p}
    \left(
        \frac{1}{\sqrt{x^2 + y^2 + z^2}}
    \right)
    \text{d}x \\,
    \text{d}y \\,
    \text{d}z
  $$

</div>
<div class="col-1">

Image of the prism and the observation point

</div>
</div>

---

## Analytic solutions: gravity fields

> Analytic solution to the gravity potential and acceleration components.
> Move the coordinate system to the next slide

<div class="container">
<div class="col-1">

* Gravity potential:
  $$
  V(\mathbf{p}) =
    G \int\limits_\Gamma
        \frac{\rho}{|\mathbf{p} - \mathbf{q}|}
    \text{d}\mathbf{q}
  $$
  $$
  V(\mathbf{p}) =
    G\rho
    \int_{x_1}^{x_2}
    \int_{y_1}^{y_2}
    \int_{z_1}^{z_2}
      \frac{
        \text{d}x \\,
        \text{d}y \\,
        \text{d}z
      }{
        \sqrt{x^2 + y^2 + z^2}
      }
  $$
* Gravity acceleration:
  $$ \mathbf{g}(\mathbf{p}) = \nabla_\mathbf{p} V(\mathbf{p}) $$
  $$
  g_x = \frac{\partial V}{\partial x_p}, \\,
  g_y = \frac{\partial V}{\partial y_p}, \\,
  g_z = \frac{\partial V}{\partial z_p}
  $$

</div>

<div class="col-1">

Coordinate system located on $\mathbf{p}$:

$$
\begin{cases}
x = x_q - x_p \newline
y = y_q - y_p \newline
z = z_q - z_p
\end{cases}
$$

image of the prism and the observation point

</div>
</div>


<div>
<p class="box-pink" style="width: 70%; margin: auto">
<strong>
Solve the gravity potential, then derive the acceleration components.
</strong>
</p>
</div>

---

## Analytic solutions: gravity fields

<div class="container">
<div class="col-1 align-left text-sm">

<div style="padding-top: 200px; padding-bottom: 200px; border-style: solid;">

Image of the prism and the observation points

</div>

Coordinate system located on $\mathbf{p}$:

$$
\begin{cases}
x = x_q - x_p \newline
y = y_q - y_p \newline
z = z_q - z_p
\end{cases}
$$

Gravity potential:
$$
V(\mathbf{p}) =
  G \int\limits_\Gamma
      \frac{\rho}{|\mathbf{p} - \mathbf{q}|}
  \text{d}\mathbf{q}
$$
$$
V(\mathbf{p}) =
  G\rho
  \int_{x_1}^{x_2}
  \int_{y_1}^{y_2}
  \int_{z_1}^{z_2}
    \frac{
      \text{d}x \\,
      \text{d}y \\,
      \text{d}z
    }{
      \sqrt{x^2 + y^2 + z^2}
    }
$$

</div>
<div class="col-1 align-left text-sm">

Define $u(\mathbf{p})$ as:
$$
V(\mathbf{p}) = G\rho \\, u(\mathbf{p})
$$

Then:
$$
u(\mathbf{p}) =
  \int_{x_1}^{x_2}
  \int_{y_1}^{y_2}
  \int_{z_1}^{z_2}
    \frac{
      \text{d}x \\,
      \text{d}y \\,
      \text{d}z
    }{
      \sqrt{x^2 + y^2 + z^2}
    }
$$


Analytic solutions for $u(\mathbf{p})$ _(Nagy et al., 2000)_:

$$
u(\mathbf{p}) =
\Bigl\lvert
\Bigl\lvert
\Bigl\lvert
k(x, y, z)
\Bigl\rvert_{x_1}^{x_2}
\Bigl\rvert_{y_1}^{y_2}
\Bigl\rvert_{z_1}^{z_2}
$$

where

$$
\begin{align*}
k(x, y, z) = \\, & x y \ln(z + r)
    + y z \ln(x + r)
    + z x \ln(y + r)
    \newline
    &- \frac{x^2}{2} \arctan \left( \frac{y z}{x r} \right)
    - \frac{y^2}{2} \arctan \left( \frac{x z}{y r} \right)
    - \frac{z^2}{2} \arctan \left( \frac{x y}{z r} \right)
    \newline
\end{align*}
$$

<div class="box-purple" style="text-align: center;">

We refer to $k(x, y, z)$ as a **kernel** function.

</div>

</div>
</div>

---

## Analytic solutions: gravity fields

<div class="container">
<div class="col-1 align-left text-sm">

Gravity acceleration components:

$$
\begin{align*}
g_x(\mathbf{p}) &= G\rho \\, u_x(\mathbf{p})
\newline
g_y(\mathbf{p}) &= G\rho \\, u_y(\mathbf{p})
\newline
g_z(\mathbf{p}) &= G\rho \\, u_z(\mathbf{p})
\end{align*}
$$

where:

$$
\begin{align*}
u_x(\mathbf{p}) &=
\Bigl\lvert \Bigl\lvert \Bigl\lvert
k_x(x, y, z)
\Bigl\rvert_{x_1}^{x_2} \Bigl\rvert_{y_1}^{y_2} \Bigl\rvert_{z_1}^{z_2}
\newline
u_y(\mathbf{p}) &=
\Bigl\lvert \Bigl\lvert \Bigl\lvert
k_y(x, y, z)
\Bigl\rvert_{x_1}^{x_2} \Bigl\rvert_{y_1}^{y_2} \Bigl\rvert_{z_1}^{z_2}
\newline
u_z(\mathbf{p}) &=
\Bigl\lvert \Bigl\lvert \Bigl\lvert
k_z(x, y, z)
\Bigl\rvert_{x_1}^{x_2} \Bigl\rvert_{y_1}^{y_2} \Bigl\rvert_{z_1}^{z_2}
\end{align*}
$$

</div>
<div class="col-1 align-left text-sm">

The first-order kernels are given by:

$$
\begin{align*}
k_x(x, y, z) &=
-\left[ y \ln(z + r) + z \ln(y + r) - x \arctan \left( \frac{y z}{x r}\right) \right]
\newline
k_y(x, y, z) &=
-\left[ z \ln(x + r) + x \ln(z + r) - y \arctan \left( \frac{x z}{y r}\right) \right]
\newline
k_z(x, y, z) &=
-\left[ x \ln(y + r) + y \ln(x + r) - z \arctan \left( \frac{x y}{z r}\right) \right]
\end{align*}
$$

</div>
</div>

---

### Gravity fields: simple implementation

<!-- > Show a dumb implementation of the gravity fields. -->

Let's write some code that computes the **vertical acceleration** due to
a **prism** on an observation point.

<!-- $$ -->
<!-- k_z(x, y, z) = -->
<!-- x \ln(y + r) + y \ln(x + r) - z \arctan \left( \frac{x y}{z r}\right) -->
<!-- $$ -->

Define prism: <!-- .element: class="align-left" -->

```python
west, east = -10.0, 10.0
south, north = -12.0, 12.0
bottom, top = -15.0, -5.0
prism = [west, east, south, north, bottom, top]
```

Define observation point: <!-- .element: class="align-left" -->

```python
coordinates = (0.0, 0.0, 2.0)
```

Implement a kernel function: <!-- .element: class="align-left" -->

```python
import numpy as np

def kernel_z(x, y, z):
    r = np.sqrt(x**2 + y**2 + z**2)
    result = -(x * np.log(y + r) + y * np.log(x + r) - z * np.arctan(x * y / z / r))
    return result
```

---

### Gravity fields: simple implementation

Define a function to evaluate the kernel on the nodes of the prism:

<pre>
<code
data-trim
data-noescape
data-line-numbers="|1|2-3|5-6|8-11|12-15|16-19|21|"
class="python hljs noscroll"
>
def evaluate_kernel(coordinates, prism, kernel):
    # Extract the coordinates of the observation point
    easting, northing, upward = coordinates

    # Initialize a result value equal to zero
    result = 0.0

    # Iterate over the vertices of the prism
    for i in range(2):
        for j in range(2):
            for k in range(2):
                # Compute shifted coordinates
                shift_east = prism[1 - i] - easting
                shift_north = prism[3 - j] - northing
                shift_upward = prism[5 - k] - upward
                # Evaluate kernel. Use the right sign.
                result += (-1) ** (i + j + k) * kernel(
                    shift_east, shift_north, shift_upward
                )

    return result
</code></pre>

---

### Gravity fields: simple implementation

Finally, define a function to compute the gravity acceleration of the prism:

```python
G = 6.6743e-11  # gravitational constant

def gravity_z(coordinates, prism, density):
    u_z = evaluate_kernel(coordinates, prism, kernel_z)
    return G * density * u_z
```

Now we can use this function to compute the vertical acceleration due to the
prism on the observation point:

```python
density = 2900.0 # kg/m3
gz = gravity_z(coordinates, prism, density)
print(f"{gz} m/s2")
```

```bash
-3.820956349021657e-06 m/s2
```

<div class="box-purple">

The result is negative because this is the **upward** acceleration component.

</div>

---

### Gravity fields: simple implementation

Let's modify the `gravity_z` function to handle multiple observation points:

<pre>
<code
data-trim
data-noescape
data-line-numbers
class="python hljs noscroll"
>
def gravity_z(coordinates, prism, density):
    easting, northing, upward = coordinates
    # Initialize an array of results
    result = np.empty(easting.size)
    # Iterate over the observation points
    for i in range(easting.size):
        # Evaluate the kernel for the current observation point
        u_z = evaluate_kernel(
          (easting[i], northing[i], upward[i]), prism, kernel_z
        )
        # Add result to the array
        result[i] = G * density * u_z
    return result
</code>
</pre>

---

### Gravity fields: simple implementation

Use it to compute $g_z$ on a grid of observation points:

<div class="container">

<div class="col-1">

<pre>
<code
data-trim
data-noescape
data-line-numbers="|1-4|6-7|9-14|16-17|"
class="python hljs noscroll"
>
# Build grid of observation points
easting = np.linspace(-30.0, 30.0, 121)
northing = np.linspace(-30.0, 30.0, 121)
easting, northing = np.meshgrid(easting, northing)

# All points are at constant height
upward = 2.0 * np.ones_like(easting)

# Put the coordinates inside a new variable
coordinates = (
  easting.ravel(),
  northing.ravel(),
  upward.ravel()
)

# Compute gz
gz = gravity_z(coordinates, prism, density)
</code>
</pre>

</div>

<div class="col-1">
<img src="images/gz-single-prism.png" alt="" style="width: 100%">
</div>

</div>



---


## Analytic solutions: magnetic fields

> Analytic solution to the magnetic field components.

---

## Software implementations

> Talk about some details of the implementation.
> Numerical accuracy.
> Limits. Singular points.

---

## Examples

$$ E = mc^2 $$
